import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

/**
 * @concept Redux Slice
 * A "slice" is a collection of Redux logic for a single feature
 * (like authentication). `createSlice` automatically generates action
 * creators and reducers for you, reducing boilerplate.
 */

// 1. Define the shape of your authentication state
interface AuthState {
  user: { name: string } | null; // Represents logged-in user data
  isLoggedIn: boolean;
  isLoading: boolean; // For tracking async operations like login
  error: string | null; // For storing authentication errors
}

// 2. Define the initial state for the auth slice
const initialState: AuthState = {
  user: null,
  isLoggedIn: false,
  isLoading: false,
  error: null,
};

// Check for stored user on initial load (similar to what we did in AuthContext)
// This happens synchronously before the component mounts.
try {
  const storedUser = localStorage.getItem('trustChainUser');
  if (storedUser) {
    initialState.user = JSON.parse(storedUser);
    initialState.isLoggedIn = true;
  }
} catch (e) {
  console.error('Failed to parse stored user from localStorage:', e);
  localStorage.removeItem('trustChainUser'); // Clear invalid data
}

/**
 * @concept Redux Thunk (with createAsyncThunk)
 * `createAsyncThunk` is an RTK utility for handling asynchronous logic.
 * It generates pending, fulfilled, and rejected action types automatically.
 * Your components will 'dispatch' this thunk.
 */
export const login = createAsyncThunk(
  'auth/login', // Action type prefix (e.g., 'auth/login/pending', 'auth/login/fulfilled')
  async (walletKey: string, { rejectWithValue }) => {
    // Simulate an API call to your FastAPI backend
    // In a real scenario:
    // const response = await api.post('/auth/login', { walletKey });
    // if (!response.ok) {
    //   return rejectWithValue(response.data.message || 'Login failed');
    // }
    // const userData = response.data.user; // Assuming user data comes from backend
    // localStorage.setItem('jwtToken', response.data.token); // Store token
    // localStorage.setItem('trustChainUser', JSON.stringify(userData));

    await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate network delay

    // Dummy validation for the wallet key
    if (walletKey.trim() === '') {
      return rejectWithValue('Wallet key cannot be empty.');
    }
    if (walletKey.length < 10) {
      return rejectWithValue('Invalid wallet key length.');
    }

    const dummyUser = { name: 'Trust Chain User' }; // Dummy user data
    localStorage.setItem('trustChainUser', JSON.stringify(dummyUser)); // Persist dummy user
    return dummyUser; // This will be the `payload` of the 'fulfilled' action
  }
);

// 3. Create the auth slice
const authSlice = createSlice({
  name: 'auth', // Name of the slice
  initialState, // The initial state
  /**
   * @concept Reducers
   * Functions that describe how state changes in response to actions.
   * `reducers` field defines "case reducers" for synchronous actions.
   * RTK uses Immer, so you can "mutate" state directly (under the hood, it's immutable).
   */
  reducers: {
    // This is a synchronous action creator for logout
    logout: (state) => {
      state.user = null;
      state.isLoggedIn = false;
      state.error = null;
      localStorage.removeItem('trustChainUser'); // Clear stored user
    },
    // You could add other synchronous actions here, e.g., setUserData, clearError
  },
  /**
   * @concept Extra Reducers
   * Used to handle actions that are defined outside of this slice (e.g., actions
   * generated by `createAsyncThunk`, or actions from other slices if needed).
   */
  extraReducers: (builder) => {
    builder
      .addCase(login.pending, (state) => {
        // When the login thunk starts
        state.isLoading = true;
        state.error = null;
        state.isLoggedIn = false; // Ensure not logged in while pending
      })
      .addCase(login.fulfilled, (state, action: PayloadAction<{ name: string }>) => {
        // When the login thunk successfully completes
        state.isLoading = false;
        state.user = action.payload; // Set user data from the thunk's return value
        state.isLoggedIn = true;
        state.error = null;
      })
      .addCase(login.rejected, (state, action) => {
        // When the login thunk fails
        state.isLoading = false;
        state.error = (action.payload as string) || 'Authentication failed'; // Error message
        state.user = null;
        state.isLoggedIn = false;
      });
  },
});

// `createSlice` automatically generates action creators from the `reducers` object.
// Exporting them allows components to dispatch these actions.
export const { logout } = authSlice.actions;

// Export the reducer function generated by `createSlice`.
// This reducer will be combined into the main store.
export default authSlice.reducer;
